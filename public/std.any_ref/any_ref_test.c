#include "api.h"

#include "lib/std.any_ref/api.h"
#include "third_party/nob.h/nob.h"
#include <stdbool.h>
#include <stddef.h>

#include "testdata/matrix4.h"
#include "testdata/vector3.h"

static void any_ref_debug(const any_ref_t *r) {
  printf("any_ref{ ptr=%08lx, type=\"%s\", size=%zu, storage=%s }\n",
         (uintptr_t)r->storage.ptr, r->type ? r->type->name : "<null>", r->size,
         r->is_inline ? "inline" : "ref");
}

// This case of return `any_ref_t` is not safe, since
// any_ref_t is non-owning, and we returning `result` which is a local variable.
// Proper way to facilitate this is to use some external allocator
// in vtable functions.
typedef struct {
  any_ref_t (*add)(any_ref_t a, any_ref_t b);
} Add_vtable_t;

vector3_t add_vector3_result = {0};
any_ref_t add_vector3(any_ref_t a, any_ref_t b) {
  vector3_t va = ANY_REF_AS(vector3_t, a);
  vector3_t vb = ANY_REF_AS(vector3_t, b);
  add_vector3_result = (vector3_t){va.x + vb.x, va.y + vb.y, va.z + vb.z};
  return ANY_FROM(add_vector3_result, vector3_t);
}
Add_vtable_t add_vector3_vtable = {
    .add = add_vector3,
};

matrix4_t add_matrix4_result = {0};
any_ref_t add_matrix4(any_ref_t a, any_ref_t b) {
  matrix4_t ma = ANY_REF_AS(matrix4_t, a);
  matrix4_t mb = ANY_REF_AS(matrix4_t, b);
  for (size_t i = 0; i < 4; ++i) {
    for (size_t j = 0; j < 4; ++j) {
      add_matrix4_result.m[i][j] = ma.m[i][j] + mb.m[i][j];
    }
  }
  return ANY_FROM(add_matrix4_result, matrix4_t);
}
Add_vtable_t add_matrix4_vtable = {
    .add = add_matrix4,
};

void add_any(Add_vtable_t vtable, any_ref_t a, any_ref_t b, any_ref_t *out) {
  *out = vtable.add(a, b);
}

// This "test" is generated by ai so it is better to be rewritten later
int main() {
  vector3_t v = {1.0F, 2.0F, 3.0F};
  vector3_ptr_t pv = &v;
  matrix4_t m = {.m = {{1.0F, 0.0F, 0.0F, 0.0F},
                       {0.0F, 1.0F, 0.0F, 0.0F},
                       {0.0F, 0.0F, 1.0F, 0.0F},
                       {0.0F, 0.0F, 0.0F, 1.0F}}};
  matrix4_ptr_t pm = &m;
  any_ref_t objs[4] = {ANY_FROM(v, vector3_t), ANY_FROM(pv, vector3_ptr_t),
                       ANY_FROM(m, matrix4_t), ANY_FROM(pm, matrix4_ptr_t)};

  for (size_t i = 0; i < 4; ++i) {
    any_ref_debug(&objs[i]);
  }

  for (size_t i = 0; i < 4; ++i) {
    any_ref_t ref = objs[i];
    if (ANY_REF_IS(vector3_t, ref)) {
      vector3_t pv = ANY_REF_AS(vector3_t, ref);
      printf("vector3_t: %f %f %f\n", pv.x, pv.y, pv.z);
    } else if (ANY_REF_IS(vector3_ptr_t, ref)) {
      const vector3_ptr_t ppv = ANY_REF_AS_CONST(vector3_ptr_t, ref);
      printf("vector3_ptr_t: %f %f %f\n", ppv->x, (ppv)->y, (ppv)->z);
    } else if (ANY_REF_IS(matrix4_t, ref)) {
      matrix4_t pm = ANY_REF_AS(matrix4_t, ref);
      printf("matrix4_t:\n");
      for (size_t i = 0; i < 4; ++i) {
        for (size_t j = 0; j < 4; ++j) {
          printf("%f ", pm.m[i][j]);
        }
        printf("\n");
      }
    } else if (ANY_REF_IS(matrix4_ptr_t, ref)) {
      const matrix4_ptr_t ppm = ANY_REF_AS_CONST(matrix4_ptr_t, ref);
      printf("matrix4_ptr_t:\n");
      for (size_t i = 0; i < 4; ++i) {
        for (size_t j = 0; j < 4; ++j) {
          printf("%f ", (ppm)->m[i][j]);
        }
        printf("\n");
      }
    } else {
      assert(false && "Unknown type");
    }
  }

  any_ref_t invalid_ref = {0};
  assert(!ANY_REF_IS(vector3_t, invalid_ref));

  any_ref_t compound_literal_ref =
      ANY_FROM(((vector3_t){4.0F, 5.0F, 6.0F}), vector3_t);
  assert(ANY_REF_IS(vector3_t, compound_literal_ref));
  vector3_t cv = ANY_REF_AS(vector3_t, compound_literal_ref);
  if (cv.x != 4.0F || cv.y != 5.0F || cv.z != 6.0F) {
    fprintf(stderr, "Compound literal value mismatch\n");
    return 1;
  }

  any_ref_t sum_ref;
  add_any(add_vector3_vtable, objs[0], compound_literal_ref, &sum_ref);
  vector3_t sum_v = ANY_REF_AS(vector3_t, sum_ref);
  if (sum_v.x != 5.0F || sum_v.y != 7.0F || sum_v.z != 9.0F) {
    fprintf(stderr, "Vector3 addition result mismatch\n");
    return 1;
  }

  add_any(add_matrix4_vtable, objs[2], objs[2], &sum_ref);
  matrix4_t sum_m = ANY_REF_AS(matrix4_t, sum_ref);
  for (size_t i = 0; i < 4; ++i) {
    for (size_t j = 0; j < 4; ++j) {
      float expected = (i == j) ? 2.0F : 0.0F;
      if (sum_m.m[i][j] != expected) {
        fprintf(stderr, "Matrix4 addition result mismatch at [%zu][%zu]\n", i,
                j);
        return 1;
      }
    }
  }

  return 0;
}